{
  "easy": [
    {
      "id": "reverse-string",
      "title": "Reverse a String",
      "category": "Algorithms",
      "description": "Write a function that takes a string as input and returns the string reversed.",
      "difficulty": "easy",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "\"hello\"",
        "output": "\"olleh\""
      },
      "hint": "Think about converting the string to an array, reversing it, and joining it back.",
      "solution": "function reverseString(str) {\n    return str.split('').reverse().join('');\n}\n\n// Alternative solution\nfunction reverseString(str) {\n    let reversed = '';\n    for (let i = str.length - 1; i >= 0; i--) {\n        reversed += str[i];\n    }\n    return reversed;\n}",
      "tags": ["strings", "arrays", "basic"]
    },
    {
      "id": "palindrome",
      "title": "Check for Palindrome",
      "category": "Algorithms",
      "description": "Write a function that checks if a given string is a palindrome (reads the same forwards and backwards).",
      "difficulty": "easy",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "\"racecar\"",
        "output": "true"
      },
      "hint": "Compare the string with its reversed version. Don't forget to handle case sensitivity.",
      "solution": "function isPalindrome(str) {\n    const normalized = str.toLowerCase().replace(/[^a-z0-9]/g, '');\n    return normalized === normalized.split('').reverse().join('');\n}",
      "tags": ["strings", "algorithms", "basic"]
    },
    {
      "id": "find-max",
      "title": "Find Maximum Number",
      "category": "Arrays",
      "description": "Write a function that finds the maximum number in an array of numbers.",
      "difficulty": "easy",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(1)",
      "example": {
        "input": "[5, 2, 9, 1, 7]",
        "output": "9"
      },
      "hint": "Iterate through the array and keep track of the largest number found so far.",
      "solution": "function findMax(arr) {\n    if (arr.length === 0) return undefined;\n    \n    let max = arr[0];\n    for (let i = 1; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i];\n        }\n    }\n    return max;\n}\n\n// Using Math.max\nfunction findMax2(arr) {\n    return Math.max(...arr);\n}",
      "tags": ["arrays", "loops", "basic"]
    }
  ],
  "medium": [
    {
      "id": "two-sum",
      "title": "Two Sum Problem",
      "category": "Algorithms",
      "description": "Given an array of integers and a target sum, find two numbers that add up to the target.",
      "difficulty": "medium",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "[2, 7, 11, 15], target = 9",
        "output": "[0, 1]"
      },
      "hint": "Use a hash map to store previously seen numbers and their indices.",
      "solution": "function twoSum(nums, target) {\n    const map = new Map();\n    \n    for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        \n        if (map.has(complement)) {\n            return [map.get(complement), i];\n        }\n        \n        map.set(nums[i], i);\n    }\n    \n    return [];\n}",
      "tags": ["arrays", "hashing", "algorithms"]
    },
    {
      "id": "valid-parentheses",
      "title": "Valid Parentheses",
      "category": "Data Structures",
      "description": "Check if a string containing only parentheses, brackets, and braces is valid.",
      "difficulty": "medium",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "\"()[]{}\"",
        "output": "true"
      },
      "hint": "Use a stack to keep track of opening brackets and match them with closing brackets.",
      "solution": "function isValidParentheses(s) {\n    const stack = [];\n    const pairs = { '(': ')', '{': '}', '[': ']' };\n    \n    for (let char of s) {\n        if (pairs[char]) {\n            stack.push(char);\n        } else {\n            const last = stack.pop();\n            if (!last || pairs[last] !== char) {\n                return false;\n            }\n        }\n    }\n    \n    return stack.length === 0;\n}",
      "tags": ["stack", "strings", "data-structures"]
    },
    {
      "id": "binary-search",
      "title": "Binary Search",
      "category": "Algorithms",
      "description": "Implement binary search to find an element in a sorted array.",
      "difficulty": "medium",
      "timeComplexity": "O(log n)",
      "spaceComplexity": "O(1)",
      "example": {
        "input": "[1, 3, 5, 7, 9], target = 5",
        "output": "2"
      },
      "hint": "Use two pointers (left and right) and repeatedly divide the search space in half.",
      "solution": "function binarySearch(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n    \n    while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n        \n        if (arr[mid] === target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n    \n    return -1;\n}",
      "tags": ["algorithms", "searching", "sorted"]
    }
  ],
  "hard": [
    {
      "id": "merge-sort",
      "title": "Merge Sort Implementation",
      "category": "Algorithms",
      "description": "Implement the merge sort algorithm to sort an array of numbers.",
      "difficulty": "hard",
      "timeComplexity": "O(n log n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "[64, 34, 25, 12, 22, 11, 90]",
        "output": "[11, 12, 22, 25, 34, 64, 90]"
      },
      "hint": "Merge sort uses divide and conquer. Split the array recursively and merge sorted subarrays.",
      "solution": "function mergeSort(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    \n    const mid = Math.floor(arr.length / 2);\n    const left = mergeSort(arr.slice(0, mid));\n    const right = mergeSort(arr.slice(mid));\n    \n    return merge(left, right);\n}\n\nfunction merge(left, right) {\n    const result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n    \n    while (leftIndex < left.length && rightIndex < right.length) {\n        if (left[leftIndex] < right[rightIndex]) {\n            result.push(left[leftIndex]);\n            leftIndex++;\n        } else {\n            result.push(right[rightIndex]);\n            rightIndex++;\n        }\n    }\n    \n    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}",
      "tags": ["sorting", "algorithms", "divide-and-conquer"]
    },
    {
      "id": "binary-search-tree",
      "title": "Binary Search Tree Implementation",
      "category": "Data Structures",
      "description": "Implement a binary search tree with insert, search, and delete operations.",
      "difficulty": "hard",
      "timeComplexity": "Average O(log n), Worst O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "Insert: [50, 30, 70, 20, 40]",
        "output": "Search: 40 -> true"
      },
      "hint": "Create a Node class with left and right pointers. Implement recursive methods for each operation.",
      "solution": "class Node {\n    constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null;\n    }\n    \n    insert(value) {\n        const newNode = new Node(value);\n        if (!this.root) {\n            this.root = newNode;\n            return;\n        }\n        \n        let current = this.root;\n        while (true) {\n            if (value < current.value) {\n                if (!current.left) {\n                    current.left = newNode;\n                    return;\n                }\n                current = current.left;\n            } else {\n                if (!current.right) {\n                    current.right = newNode;\n                    return;\n                }\n                current = current.right;\n            }\n        }\n    }\n    \n    search(value) {\n        let current = this.root;\n        while (current) {\n            if (value === current.value) return true;\n            if (value < current.value) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n        return false;\n    }\n}",
      "tags": ["data-structures", "trees", "binary"]
    },
    {
      "id": "dynamic-programming-fibonacci",
      "title": "Dynamic Programming - Fibonacci",
      "category": "Dynamic Programming",
      "description": "Implement Fibonacci sequence using dynamic programming with memoization.",
      "difficulty": "hard",
      "timeComplexity": "O(n)",
      "spaceComplexity": "O(n)",
      "example": {
        "input": "n = 10",
        "output": "55"
      },
      "hint": "Use memoization to store previously computed values and avoid redundant calculations.",
      "solution": "function fibonacci(n, memo = {}) {\n    if (n in memo) return memo[n];\n    if (n <= 2) return 1;\n    \n    memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);\n    return memo[n];\n}\n\n// Iterative approach (bottom-up DP)\nfunction fibonacciIterative(n) {\n    if (n <= 2) return 1;\n    \n    const dp = [0, 1, 1];\n    for (let i = 3; i <= n; i++) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n    \n    return dp[n];\n}\n\n// Space optimized iterative approach\nfunction fibonacciOptimized(n) {\n    if (n <= 2) return 1;\n    \n    let prev = 1;\n    let curr = 1;\n    \n    for (let i = 3; i <= n; i++) {\n        const next = prev + curr;\n        prev = curr;\n        curr = next;\n    }\n    \n    return curr;\n}",
      "tags": ["dynamic-programming", "recursion", "optimization"]
    }
  ]
}